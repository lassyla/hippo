
<style>
  body {
    text-align: center;
    background: linear-gradient(lightblue, peachpuff);
  }
  svg{
    text-align: center;
  }
  .dashedPath{
    stroke-width: 5px;
    opacity: .5;
    stroke: white;
    stroke-dasharray: 5, 5;
  }
  g{
    stroke: white;
    transition: .5s;
  }
  #distance{
    fill: white;
    stroke: none;
  }
  text{
    fill: white;
    font-size: 250px;
    opacity: .25;
    text-anchor: middle;
  }
  .examplePath{
    stroke-width: 3px;
    stroke: red;
  }
</style>
<body>
  <div id="container"> </div>
  <button onclick="reset()">reset</button>
  <button onclick="randomize()">randomize</button>
  <button onClick="showPath([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])"> show path </button>
  <button onClick="hidePath()">hide path</button>
  <button onClick="newNumbers()"> get new numbers </button>

</body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>
//TSP
//see if you can beat a poly time algorithm
//:)
  var width = 500;
  var height = 500;
  var padding = 20;
  var numPoints = 11;
  var defs;
  var edgeMatrix;
  var points;
  var hippo;
  var currentNode = 0;
  var imgRadius = 20;
  var speed = 6;
  var visitedNodes = [];
  var moving;
  var distanceTraveled = 0;
  getPoints();
  drawStuff();

  function randomColor(){
    return "hsl(" + Math.random() * 360 + ", 100%, 50%)";
  }

  function getDist(node1, node2) {
    return Math.round(Math.sqrt(Math.pow(points[node1][0]-points[node2][0], 2) + Math.pow(points[node1][1]-points[node2][1], 2)))
  }

  function getPoints() {
    points = [[padding, height + padding, 0, randomColor()]];
    for(var i = 1; i < numPoints-1; i++){
      points.push([Math.random()*height + padding, Math.random()*width + padding, i, randomColor()]);
    }
    points.push([width + padding, padding, numPoints - 1, randomColor()]);
    edgeMatrix = [];
    for(var i = 0; i < numPoints; i++){
      edgeMatrix[i] = []
      for(var j = 0; j < i; j++){
        dist = getDist(i, j)
        edgeMatrix[i][j] = dist;
        edgeMatrix[j][i] = dist;
      }
    }
  }

  function drawStuff(){
    d3.select("body").select("svg").remove(); //deleting anything

    var svg = d3.select("body")
      .append("svg")
      .attr("width", width + padding * 2)
      .attr("height", height + padding * 2);

    svg.append("g")
      .attr("id", "dashedlines");


    svg.append("g")
      .append("text")
      .attr("x", width / 2 + padding)
      .attr("y", height / 2 + padding)
      .text(distanceTraveled);

    var nodes = d3.select("svg")
      .selectAll("dot")
        .data(points)
      .enter().append("circle")
        .attr("r", 10)
        .attr("fill", (d, i)=>points[i][3])
        .attr("cx", (d, i)=>points[i][0])
        .attr("cy",  (d, i)=>points[i][1])
        .attr("id", (d) => "circle" + d)
        .on("click", function(d, i){travelTo(i, this)})

    hippo = d3.select("svg")
      .append("svg:image")
      .attr("xlink:href", "square.png")
      .attr("width", imgRadius * 2)
      .attr("height", imgRadius * 2)
      .attr("opacity", .5)
      .attr("x", padding - imgRadius)
      .attr("y", height + padding - imgRadius);
  }

  function newNumbers() {
    d3.select("svg")
      .selectAll("*")
      .transition()
      .duration(500)
      .style("opacity", 0)
      .each("end", function(){
        getPoints();
        drawStuff();
      });
  }

  function randomize() {
    getPoints();
    moving = true;
    d3.selectAll("circle")
      .transition()
        .duration(2000)
        .attr("fill", (d, i)=>points[i][3])
        .attr("cx", (d, i)=>points[i][0])
        .attr("cy",  (d, i)=>points[i][1])
        .each("end", function(){moving = false; reset();});
  }

  function showPath(path){
    hidePath();
    pathDist = 0;
    for(var i = 1; i < path.length; i ++){
      var line = d3.select("g").append("line")
        .attr("x1", points[path[i-1]][0])
        .attr("y1", points[path[i-1]][1])
        .attr("x2", points[path[i]][0])
        .attr("y2", points[path[i]][1])
        .attr("class", "examplePath")
      pathDist += getDist(i-1, i);
    }
  }

  function travelTo(index, node) {
    if(!visitedNodes.includes(index) && !moving){
      moving = true;
      var dist = getDist(index, currentNode);
      var line = d3.select("g").append("line")
        .attr("x1", points[currentNode][0])
        .attr("y1", points[currentNode][1])
        .attr("x2", points[currentNode][0])
        .attr("y2", points[currentNode][1])
        .attr("class", "dashedPath")
      visitedNodes.push(index);
      distanceTraveled += dist;
      currentNode = index;

      hippo.transition()
        .ease("linear")
        .duration( dist * 10 / speed)
        .attr("x", points[index][0] - imgRadius)
        .attr("y", points[index][1] - imgRadius)
        .each("end", function(){
          moving = false;
          d3.select(node).transition().attr("r", 4);
          d3.select("text").text(distanceTraveled);
        });

      line.transition()
        .ease("linear")
        .duration( dist * 10 / speed)
        .attr("x2", points[index][0])
        .attr("y2", points[index][1])
    }
  }

  function reset(){
    if(!moving){
      d3.selectAll("circle").transition().duration(500).attr("r", 10);
      visitedNodes = [];
      travelTo(0);
      d3.select("#dashedlines")
        .selectAll("line")
        .transition()
        .duration(1000)
        .style("opacity", 0)
        .each("end", function(){
          d3.select(this).remove();
          d3.select("text").text("0");
          distanceTraveled = 0;
        })
      }
  }

  function hidePath() {
      d3.selectAll(".examplePath").remove();
  }

  function nearestNeighbor(node) {
    return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  }
</script>
